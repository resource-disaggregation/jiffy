/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "block_service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jiffy { namespace storage {

int _kresponse_typeValues[] = {
  subscribe,
  unsubscribe
};
const char* _kresponse_typeNames[] = {
  "subscribe",
  "unsubscribe"
};
const std::map<int, const char*> _response_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kresponse_typeValues, _kresponse_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const response_type val) {
  std::map<int, const char*>::const_iterator it = _response_type_VALUES_TO_NAMES.find(val);
  if (it != _response_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


block_exception::~block_exception() throw() {
}


void block_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const block_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(block_exception &a, block_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

block_exception::block_exception(const block_exception& other0) : TException() {
  msg = other0.msg;
  __isset = other0.__isset;
}
block_exception& block_exception::operator=(const block_exception& other1) {
  msg = other1.msg;
  __isset = other1.__isset;
  return *this;
}
void block_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "block_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* block_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: block_exception";
  }
}


chain_failure_exception::~chain_failure_exception() throw() {
}


void chain_failure_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const chain_failure_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(chain_failure_exception &a, chain_failure_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

chain_failure_exception::chain_failure_exception(const chain_failure_exception& other2) : TException() {
  msg = other2.msg;
  __isset = other2.__isset;
}
chain_failure_exception& chain_failure_exception::operator=(const chain_failure_exception& other3) {
  msg = other3.msg;
  __isset = other3.__isset;
  return *this;
}
void chain_failure_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "chain_failure_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* chain_failure_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: chain_failure_exception";
  }
}


sequence_id::~sequence_id() throw() {
}


void sequence_id::__set_client_id(const int64_t val) {
  this->client_id = val;
}

void sequence_id::__set_client_seq_no(const int64_t val) {
  this->client_seq_no = val;
}

void sequence_id::__set_server_seq_no(const int64_t val) {
  this->server_seq_no = val;
}
std::ostream& operator<<(std::ostream& out, const sequence_id& obj)
{
  obj.printTo(out);
  return out;
}


void swap(sequence_id &a, sequence_id &b) {
  using ::std::swap;
  swap(a.client_id, b.client_id);
  swap(a.client_seq_no, b.client_seq_no);
  swap(a.server_seq_no, b.server_seq_no);
}

sequence_id::sequence_id(const sequence_id& other4) {
  client_id = other4.client_id;
  client_seq_no = other4.client_seq_no;
  server_seq_no = other4.server_seq_no;
}
sequence_id& sequence_id::operator=(const sequence_id& other5) {
  client_id = other5.client_id;
  client_seq_no = other5.client_seq_no;
  server_seq_no = other5.server_seq_no;
  return *this;
}
void sequence_id::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sequence_id(";
  out << "client_id=" << to_string(client_id);
  out << ", " << "client_seq_no=" << to_string(client_seq_no);
  out << ", " << "server_seq_no=" << to_string(server_seq_no);
  out << ")";
}

}} // namespace
