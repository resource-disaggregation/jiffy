/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef directory_service_H
#define directory_service_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "directory_service_types.h"

namespace jiffy { namespace directory {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class directory_serviceIf {
 public:
  virtual ~directory_serviceIf() {}
  virtual void create_directory(const std::string& path) = 0;
  virtual void create_directories(const std::string& path) = 0;
  virtual void open(rpc_data_status& _return, const std::string& path) = 0;
  virtual void create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags) = 0;
  virtual void open_or_create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags) = 0;
  virtual bool exists(const std::string& path) = 0;
  virtual int64_t last_write_time(const std::string& path) = 0;
  virtual void set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts) = 0;
  virtual rpc_perms get_permissions(const std::string& path) = 0;
  virtual void remove(const std::string& path) = 0;
  virtual void remove_all(const std::string& path) = 0;
  virtual void sync(const std::string& path, const std::string& backing_path) = 0;
  virtual void dump(const std::string& path, const std::string& backing_path) = 0;
  virtual void load(const std::string& path, const std::string& backing_path) = 0;
  virtual void rename(const std::string& old_path, const std::string& new_path) = 0;
  virtual void status(rpc_file_status& _return, const std::string& path) = 0;
  virtual void directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path) = 0;
  virtual void recursive_directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path) = 0;
  virtual void dstatus(rpc_data_status& _return, const std::string& path) = 0;
  virtual void add_tags(const std::string& path, const std::map<std::string, std::string> & tags) = 0;
  virtual bool is_regular_file(const std::string& path) = 0;
  virtual bool is_directory(const std::string& path) = 0;
  virtual void reslove_failures(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain) = 0;
  virtual void add_replica_to_chain(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain) = 0;
  virtual void add_data_block(rpc_replica_chain& _return, const std::string& path, const std::string& partition_name, const std::string& partition_metadata) = 0;
  virtual void remove_data_block(const std::string& path, const std::string& partition_name) = 0;
  virtual void request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata) = 0;
  virtual int64_t get_storage_capacity(const std::string& path, const std::string& partition_name) = 0;
};

class directory_serviceIfFactory {
 public:
  typedef directory_serviceIf Handler;

  virtual ~directory_serviceIfFactory() {}

  virtual directory_serviceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(directory_serviceIf* /* handler */) = 0;
};

class directory_serviceIfSingletonFactory : virtual public directory_serviceIfFactory {
 public:
  directory_serviceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<directory_serviceIf>& iface) : iface_(iface) {}
  virtual ~directory_serviceIfSingletonFactory() {}

  virtual directory_serviceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(directory_serviceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<directory_serviceIf> iface_;
};

class directory_serviceNull : virtual public directory_serviceIf {
 public:
  virtual ~directory_serviceNull() {}
  void create_directory(const std::string& /* path */) {
    return;
  }
  void create_directories(const std::string& /* path */) {
    return;
  }
  void open(rpc_data_status& /* _return */, const std::string& /* path */) {
    return;
  }
  void create(rpc_data_status& /* _return */, const std::string& /* path */, const std::string& /* type */, const std::string& /* backing_path */, const int32_t /* num_blocks */, const int32_t /* chain_length */, const int32_t /* flags */, const int32_t /* permissions */, const std::vector<std::string> & /* block_ids */, const std::vector<std::string> & /* block_metadata */, const std::map<std::string, std::string> & /* tags */) {
    return;
  }
  void open_or_create(rpc_data_status& /* _return */, const std::string& /* path */, const std::string& /* type */, const std::string& /* backing_path */, const int32_t /* num_blocks */, const int32_t /* chain_length */, const int32_t /* flags */, const int32_t /* permissions */, const std::vector<std::string> & /* block_ids */, const std::vector<std::string> & /* block_metadata */, const std::map<std::string, std::string> & /* tags */) {
    return;
  }
  bool exists(const std::string& /* path */) {
    bool _return = false;
    return _return;
  }
  int64_t last_write_time(const std::string& /* path */) {
    int64_t _return = 0;
    return _return;
  }
  void set_permissions(const std::string& /* path */, const rpc_perms /* perms */, const rpc_perm_options /* opts */) {
    return;
  }
  rpc_perms get_permissions(const std::string& /* path */) {
    rpc_perms _return = 0;
    return _return;
  }
  void remove(const std::string& /* path */) {
    return;
  }
  void remove_all(const std::string& /* path */) {
    return;
  }
  void sync(const std::string& /* path */, const std::string& /* backing_path */) {
    return;
  }
  void dump(const std::string& /* path */, const std::string& /* backing_path */) {
    return;
  }
  void load(const std::string& /* path */, const std::string& /* backing_path */) {
    return;
  }
  void rename(const std::string& /* old_path */, const std::string& /* new_path */) {
    return;
  }
  void status(rpc_file_status& /* _return */, const std::string& /* path */) {
    return;
  }
  void directory_entries(std::vector<rpc_dir_entry> & /* _return */, const std::string& /* path */) {
    return;
  }
  void recursive_directory_entries(std::vector<rpc_dir_entry> & /* _return */, const std::string& /* path */) {
    return;
  }
  void dstatus(rpc_data_status& /* _return */, const std::string& /* path */) {
    return;
  }
  void add_tags(const std::string& /* path */, const std::map<std::string, std::string> & /* tags */) {
    return;
  }
  bool is_regular_file(const std::string& /* path */) {
    bool _return = false;
    return _return;
  }
  bool is_directory(const std::string& /* path */) {
    bool _return = false;
    return _return;
  }
  void reslove_failures(rpc_replica_chain& /* _return */, const std::string& /* path */, const rpc_replica_chain& /* chain */) {
    return;
  }
  void add_replica_to_chain(rpc_replica_chain& /* _return */, const std::string& /* path */, const rpc_replica_chain& /* chain */) {
    return;
  }
  void add_data_block(rpc_replica_chain& /* _return */, const std::string& /* path */, const std::string& /* partition_name */, const std::string& /* partition_metadata */) {
    return;
  }
  void remove_data_block(const std::string& /* path */, const std::string& /* partition_name */) {
    return;
  }
  void request_partition_data_update(const std::string& /* path */, const std::string& /* old_partition_name */, const std::string& /* new_partition_name */, const std::string& /* partition_metadata */) {
    return;
  }
  int64_t get_storage_capacity(const std::string& /* path */, const std::string& /* partition_name */) {
    int64_t _return = 0;
    return _return;
  }
};

typedef struct _directory_service_create_directory_args__isset {
  _directory_service_create_directory_args__isset() : path(false) {}
  bool path :1;
} _directory_service_create_directory_args__isset;

class directory_service_create_directory_args {
 public:

  directory_service_create_directory_args(const directory_service_create_directory_args&);
  directory_service_create_directory_args& operator=(const directory_service_create_directory_args&);
  directory_service_create_directory_args() : path() {
  }

  virtual ~directory_service_create_directory_args() throw();
  std::string path;

  _directory_service_create_directory_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_create_directory_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_directory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_directory_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_create_directory_pargs {
 public:


  virtual ~directory_service_create_directory_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_directory_result__isset {
  _directory_service_create_directory_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_create_directory_result__isset;

class directory_service_create_directory_result {
 public:

  directory_service_create_directory_result(const directory_service_create_directory_result&);
  directory_service_create_directory_result& operator=(const directory_service_create_directory_result&);
  directory_service_create_directory_result() {
  }

  virtual ~directory_service_create_directory_result() throw();
  directory_service_exception ex;

  _directory_service_create_directory_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_create_directory_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_directory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_directory_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_directory_presult__isset {
  _directory_service_create_directory_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_create_directory_presult__isset;

class directory_service_create_directory_presult {
 public:


  virtual ~directory_service_create_directory_presult() throw();
  directory_service_exception ex;

  _directory_service_create_directory_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_create_directories_args__isset {
  _directory_service_create_directories_args__isset() : path(false) {}
  bool path :1;
} _directory_service_create_directories_args__isset;

class directory_service_create_directories_args {
 public:

  directory_service_create_directories_args(const directory_service_create_directories_args&);
  directory_service_create_directories_args& operator=(const directory_service_create_directories_args&);
  directory_service_create_directories_args() : path() {
  }

  virtual ~directory_service_create_directories_args() throw();
  std::string path;

  _directory_service_create_directories_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_create_directories_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_directories_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_directories_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_create_directories_pargs {
 public:


  virtual ~directory_service_create_directories_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_directories_result__isset {
  _directory_service_create_directories_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_create_directories_result__isset;

class directory_service_create_directories_result {
 public:

  directory_service_create_directories_result(const directory_service_create_directories_result&);
  directory_service_create_directories_result& operator=(const directory_service_create_directories_result&);
  directory_service_create_directories_result() {
  }

  virtual ~directory_service_create_directories_result() throw();
  directory_service_exception ex;

  _directory_service_create_directories_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_create_directories_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_directories_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_directories_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_directories_presult__isset {
  _directory_service_create_directories_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_create_directories_presult__isset;

class directory_service_create_directories_presult {
 public:


  virtual ~directory_service_create_directories_presult() throw();
  directory_service_exception ex;

  _directory_service_create_directories_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_open_args__isset {
  _directory_service_open_args__isset() : path(false) {}
  bool path :1;
} _directory_service_open_args__isset;

class directory_service_open_args {
 public:

  directory_service_open_args(const directory_service_open_args&);
  directory_service_open_args& operator=(const directory_service_open_args&);
  directory_service_open_args() : path() {
  }

  virtual ~directory_service_open_args() throw();
  std::string path;

  _directory_service_open_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_open_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_open_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_open_pargs {
 public:


  virtual ~directory_service_open_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_open_result__isset {
  _directory_service_open_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_open_result__isset;

class directory_service_open_result {
 public:

  directory_service_open_result(const directory_service_open_result&);
  directory_service_open_result& operator=(const directory_service_open_result&);
  directory_service_open_result() {
  }

  virtual ~directory_service_open_result() throw();
  rpc_data_status success;
  directory_service_exception ex;

  _directory_service_open_result__isset __isset;

  void __set_success(const rpc_data_status& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_open_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_open_presult__isset {
  _directory_service_open_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_open_presult__isset;

class directory_service_open_presult {
 public:


  virtual ~directory_service_open_presult() throw();
  rpc_data_status* success;
  directory_service_exception ex;

  _directory_service_open_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_create_args__isset {
  _directory_service_create_args__isset() : path(false), type(false), backing_path(false), num_blocks(false), chain_length(false), flags(false), permissions(false), block_ids(false), block_metadata(false), tags(false) {}
  bool path :1;
  bool type :1;
  bool backing_path :1;
  bool num_blocks :1;
  bool chain_length :1;
  bool flags :1;
  bool permissions :1;
  bool block_ids :1;
  bool block_metadata :1;
  bool tags :1;
} _directory_service_create_args__isset;

class directory_service_create_args {
 public:

  directory_service_create_args(const directory_service_create_args&);
  directory_service_create_args& operator=(const directory_service_create_args&);
  directory_service_create_args() : path(), type(), backing_path(), num_blocks(0), chain_length(0), flags(0), permissions(0) {
  }

  virtual ~directory_service_create_args() throw();
  std::string path;
  std::string type;
  std::string backing_path;
  int32_t num_blocks;
  int32_t chain_length;
  int32_t flags;
  int32_t permissions;
  std::vector<std::string>  block_ids;
  std::vector<std::string>  block_metadata;
  std::map<std::string, std::string>  tags;

  _directory_service_create_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_type(const std::string& val);

  void __set_backing_path(const std::string& val);

  void __set_num_blocks(const int32_t val);

  void __set_chain_length(const int32_t val);

  void __set_flags(const int32_t val);

  void __set_permissions(const int32_t val);

  void __set_block_ids(const std::vector<std::string> & val);

  void __set_block_metadata(const std::vector<std::string> & val);

  void __set_tags(const std::map<std::string, std::string> & val);

  bool operator == (const directory_service_create_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(backing_path == rhs.backing_path))
      return false;
    if (!(num_blocks == rhs.num_blocks))
      return false;
    if (!(chain_length == rhs.chain_length))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    if (!(block_ids == rhs.block_ids))
      return false;
    if (!(block_metadata == rhs.block_metadata))
      return false;
    if (!(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_create_pargs {
 public:


  virtual ~directory_service_create_pargs() throw();
  const std::string* path;
  const std::string* type;
  const std::string* backing_path;
  const int32_t* num_blocks;
  const int32_t* chain_length;
  const int32_t* flags;
  const int32_t* permissions;
  const std::vector<std::string> * block_ids;
  const std::vector<std::string> * block_metadata;
  const std::map<std::string, std::string> * tags;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_result__isset {
  _directory_service_create_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_create_result__isset;

class directory_service_create_result {
 public:

  directory_service_create_result(const directory_service_create_result&);
  directory_service_create_result& operator=(const directory_service_create_result&);
  directory_service_create_result() {
  }

  virtual ~directory_service_create_result() throw();
  rpc_data_status success;
  directory_service_exception ex;

  _directory_service_create_result__isset __isset;

  void __set_success(const rpc_data_status& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_create_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_create_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_create_presult__isset {
  _directory_service_create_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_create_presult__isset;

class directory_service_create_presult {
 public:


  virtual ~directory_service_create_presult() throw();
  rpc_data_status* success;
  directory_service_exception ex;

  _directory_service_create_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_open_or_create_args__isset {
  _directory_service_open_or_create_args__isset() : path(false), type(false), backing_path(false), num_blocks(false), chain_length(false), flags(false), permissions(false), block_ids(false), block_metadata(false), tags(false) {}
  bool path :1;
  bool type :1;
  bool backing_path :1;
  bool num_blocks :1;
  bool chain_length :1;
  bool flags :1;
  bool permissions :1;
  bool block_ids :1;
  bool block_metadata :1;
  bool tags :1;
} _directory_service_open_or_create_args__isset;

class directory_service_open_or_create_args {
 public:

  directory_service_open_or_create_args(const directory_service_open_or_create_args&);
  directory_service_open_or_create_args& operator=(const directory_service_open_or_create_args&);
  directory_service_open_or_create_args() : path(), type(), backing_path(), num_blocks(0), chain_length(0), flags(0), permissions(0) {
  }

  virtual ~directory_service_open_or_create_args() throw();
  std::string path;
  std::string type;
  std::string backing_path;
  int32_t num_blocks;
  int32_t chain_length;
  int32_t flags;
  int32_t permissions;
  std::vector<std::string>  block_ids;
  std::vector<std::string>  block_metadata;
  std::map<std::string, std::string>  tags;

  _directory_service_open_or_create_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_type(const std::string& val);

  void __set_backing_path(const std::string& val);

  void __set_num_blocks(const int32_t val);

  void __set_chain_length(const int32_t val);

  void __set_flags(const int32_t val);

  void __set_permissions(const int32_t val);

  void __set_block_ids(const std::vector<std::string> & val);

  void __set_block_metadata(const std::vector<std::string> & val);

  void __set_tags(const std::map<std::string, std::string> & val);

  bool operator == (const directory_service_open_or_create_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(backing_path == rhs.backing_path))
      return false;
    if (!(num_blocks == rhs.num_blocks))
      return false;
    if (!(chain_length == rhs.chain_length))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    if (!(block_ids == rhs.block_ids))
      return false;
    if (!(block_metadata == rhs.block_metadata))
      return false;
    if (!(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const directory_service_open_or_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_open_or_create_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_open_or_create_pargs {
 public:


  virtual ~directory_service_open_or_create_pargs() throw();
  const std::string* path;
  const std::string* type;
  const std::string* backing_path;
  const int32_t* num_blocks;
  const int32_t* chain_length;
  const int32_t* flags;
  const int32_t* permissions;
  const std::vector<std::string> * block_ids;
  const std::vector<std::string> * block_metadata;
  const std::map<std::string, std::string> * tags;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_open_or_create_result__isset {
  _directory_service_open_or_create_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_open_or_create_result__isset;

class directory_service_open_or_create_result {
 public:

  directory_service_open_or_create_result(const directory_service_open_or_create_result&);
  directory_service_open_or_create_result& operator=(const directory_service_open_or_create_result&);
  directory_service_open_or_create_result() {
  }

  virtual ~directory_service_open_or_create_result() throw();
  rpc_data_status success;
  directory_service_exception ex;

  _directory_service_open_or_create_result__isset __isset;

  void __set_success(const rpc_data_status& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_open_or_create_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_open_or_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_open_or_create_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_open_or_create_presult__isset {
  _directory_service_open_or_create_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_open_or_create_presult__isset;

class directory_service_open_or_create_presult {
 public:


  virtual ~directory_service_open_or_create_presult() throw();
  rpc_data_status* success;
  directory_service_exception ex;

  _directory_service_open_or_create_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_exists_args__isset {
  _directory_service_exists_args__isset() : path(false) {}
  bool path :1;
} _directory_service_exists_args__isset;

class directory_service_exists_args {
 public:

  directory_service_exists_args(const directory_service_exists_args&);
  directory_service_exists_args& operator=(const directory_service_exists_args&);
  directory_service_exists_args() : path() {
  }

  virtual ~directory_service_exists_args() throw();
  std::string path;

  _directory_service_exists_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_exists_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_exists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_exists_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_exists_pargs {
 public:


  virtual ~directory_service_exists_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_exists_result__isset {
  _directory_service_exists_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_exists_result__isset;

class directory_service_exists_result {
 public:

  directory_service_exists_result(const directory_service_exists_result&);
  directory_service_exists_result& operator=(const directory_service_exists_result&);
  directory_service_exists_result() : success(0) {
  }

  virtual ~directory_service_exists_result() throw();
  bool success;
  directory_service_exception ex;

  _directory_service_exists_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_exists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_exists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_exists_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_exists_presult__isset {
  _directory_service_exists_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_exists_presult__isset;

class directory_service_exists_presult {
 public:


  virtual ~directory_service_exists_presult() throw();
  bool* success;
  directory_service_exception ex;

  _directory_service_exists_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_last_write_time_args__isset {
  _directory_service_last_write_time_args__isset() : path(false) {}
  bool path :1;
} _directory_service_last_write_time_args__isset;

class directory_service_last_write_time_args {
 public:

  directory_service_last_write_time_args(const directory_service_last_write_time_args&);
  directory_service_last_write_time_args& operator=(const directory_service_last_write_time_args&);
  directory_service_last_write_time_args() : path() {
  }

  virtual ~directory_service_last_write_time_args() throw();
  std::string path;

  _directory_service_last_write_time_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_last_write_time_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_last_write_time_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_last_write_time_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_last_write_time_pargs {
 public:


  virtual ~directory_service_last_write_time_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_last_write_time_result__isset {
  _directory_service_last_write_time_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_last_write_time_result__isset;

class directory_service_last_write_time_result {
 public:

  directory_service_last_write_time_result(const directory_service_last_write_time_result&);
  directory_service_last_write_time_result& operator=(const directory_service_last_write_time_result&);
  directory_service_last_write_time_result() : success(0) {
  }

  virtual ~directory_service_last_write_time_result() throw();
  int64_t success;
  directory_service_exception ex;

  _directory_service_last_write_time_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_last_write_time_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_last_write_time_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_last_write_time_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_last_write_time_presult__isset {
  _directory_service_last_write_time_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_last_write_time_presult__isset;

class directory_service_last_write_time_presult {
 public:


  virtual ~directory_service_last_write_time_presult() throw();
  int64_t* success;
  directory_service_exception ex;

  _directory_service_last_write_time_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_set_permissions_args__isset {
  _directory_service_set_permissions_args__isset() : path(false), perms(false), opts(false) {}
  bool path :1;
  bool perms :1;
  bool opts :1;
} _directory_service_set_permissions_args__isset;

class directory_service_set_permissions_args {
 public:

  directory_service_set_permissions_args(const directory_service_set_permissions_args&);
  directory_service_set_permissions_args& operator=(const directory_service_set_permissions_args&);
  directory_service_set_permissions_args() : path(), perms(0), opts((rpc_perm_options)0) {
  }

  virtual ~directory_service_set_permissions_args() throw();
  std::string path;
  rpc_perms perms;
  rpc_perm_options opts;

  _directory_service_set_permissions_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_perms(const rpc_perms val);

  void __set_opts(const rpc_perm_options val);

  bool operator == (const directory_service_set_permissions_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(perms == rhs.perms))
      return false;
    if (!(opts == rhs.opts))
      return false;
    return true;
  }
  bool operator != (const directory_service_set_permissions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_set_permissions_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_set_permissions_pargs {
 public:


  virtual ~directory_service_set_permissions_pargs() throw();
  const std::string* path;
  const rpc_perms* perms;
  const rpc_perm_options* opts;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_set_permissions_result__isset {
  _directory_service_set_permissions_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_set_permissions_result__isset;

class directory_service_set_permissions_result {
 public:

  directory_service_set_permissions_result(const directory_service_set_permissions_result&);
  directory_service_set_permissions_result& operator=(const directory_service_set_permissions_result&);
  directory_service_set_permissions_result() {
  }

  virtual ~directory_service_set_permissions_result() throw();
  directory_service_exception ex;

  _directory_service_set_permissions_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_set_permissions_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_set_permissions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_set_permissions_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_set_permissions_presult__isset {
  _directory_service_set_permissions_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_set_permissions_presult__isset;

class directory_service_set_permissions_presult {
 public:


  virtual ~directory_service_set_permissions_presult() throw();
  directory_service_exception ex;

  _directory_service_set_permissions_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_get_permissions_args__isset {
  _directory_service_get_permissions_args__isset() : path(false) {}
  bool path :1;
} _directory_service_get_permissions_args__isset;

class directory_service_get_permissions_args {
 public:

  directory_service_get_permissions_args(const directory_service_get_permissions_args&);
  directory_service_get_permissions_args& operator=(const directory_service_get_permissions_args&);
  directory_service_get_permissions_args() : path() {
  }

  virtual ~directory_service_get_permissions_args() throw();
  std::string path;

  _directory_service_get_permissions_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_get_permissions_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_get_permissions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_get_permissions_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_get_permissions_pargs {
 public:


  virtual ~directory_service_get_permissions_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_get_permissions_result__isset {
  _directory_service_get_permissions_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_get_permissions_result__isset;

class directory_service_get_permissions_result {
 public:

  directory_service_get_permissions_result(const directory_service_get_permissions_result&);
  directory_service_get_permissions_result& operator=(const directory_service_get_permissions_result&);
  directory_service_get_permissions_result() : success(0) {
  }

  virtual ~directory_service_get_permissions_result() throw();
  rpc_perms success;
  directory_service_exception ex;

  _directory_service_get_permissions_result__isset __isset;

  void __set_success(const rpc_perms val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_get_permissions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_get_permissions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_get_permissions_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_get_permissions_presult__isset {
  _directory_service_get_permissions_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_get_permissions_presult__isset;

class directory_service_get_permissions_presult {
 public:


  virtual ~directory_service_get_permissions_presult() throw();
  rpc_perms* success;
  directory_service_exception ex;

  _directory_service_get_permissions_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_remove_args__isset {
  _directory_service_remove_args__isset() : path(false) {}
  bool path :1;
} _directory_service_remove_args__isset;

class directory_service_remove_args {
 public:

  directory_service_remove_args(const directory_service_remove_args&);
  directory_service_remove_args& operator=(const directory_service_remove_args&);
  directory_service_remove_args() : path() {
  }

  virtual ~directory_service_remove_args() throw();
  std::string path;

  _directory_service_remove_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_remove_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_remove_pargs {
 public:


  virtual ~directory_service_remove_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_result__isset {
  _directory_service_remove_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_result__isset;

class directory_service_remove_result {
 public:

  directory_service_remove_result(const directory_service_remove_result&);
  directory_service_remove_result& operator=(const directory_service_remove_result&);
  directory_service_remove_result() {
  }

  virtual ~directory_service_remove_result() throw();
  directory_service_exception ex;

  _directory_service_remove_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_remove_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_presult__isset {
  _directory_service_remove_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_presult__isset;

class directory_service_remove_presult {
 public:


  virtual ~directory_service_remove_presult() throw();
  directory_service_exception ex;

  _directory_service_remove_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_remove_all_args__isset {
  _directory_service_remove_all_args__isset() : path(false) {}
  bool path :1;
} _directory_service_remove_all_args__isset;

class directory_service_remove_all_args {
 public:

  directory_service_remove_all_args(const directory_service_remove_all_args&);
  directory_service_remove_all_args& operator=(const directory_service_remove_all_args&);
  directory_service_remove_all_args() : path() {
  }

  virtual ~directory_service_remove_all_args() throw();
  std::string path;

  _directory_service_remove_all_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_remove_all_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_all_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_all_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_remove_all_pargs {
 public:


  virtual ~directory_service_remove_all_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_all_result__isset {
  _directory_service_remove_all_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_all_result__isset;

class directory_service_remove_all_result {
 public:

  directory_service_remove_all_result(const directory_service_remove_all_result&);
  directory_service_remove_all_result& operator=(const directory_service_remove_all_result&);
  directory_service_remove_all_result() {
  }

  virtual ~directory_service_remove_all_result() throw();
  directory_service_exception ex;

  _directory_service_remove_all_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_remove_all_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_all_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_all_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_all_presult__isset {
  _directory_service_remove_all_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_all_presult__isset;

class directory_service_remove_all_presult {
 public:


  virtual ~directory_service_remove_all_presult() throw();
  directory_service_exception ex;

  _directory_service_remove_all_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_sync_args__isset {
  _directory_service_sync_args__isset() : path(false), backing_path(false) {}
  bool path :1;
  bool backing_path :1;
} _directory_service_sync_args__isset;

class directory_service_sync_args {
 public:

  directory_service_sync_args(const directory_service_sync_args&);
  directory_service_sync_args& operator=(const directory_service_sync_args&);
  directory_service_sync_args() : path(), backing_path() {
  }

  virtual ~directory_service_sync_args() throw();
  std::string path;
  std::string backing_path;

  _directory_service_sync_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_backing_path(const std::string& val);

  bool operator == (const directory_service_sync_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(backing_path == rhs.backing_path))
      return false;
    return true;
  }
  bool operator != (const directory_service_sync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_sync_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_sync_pargs {
 public:


  virtual ~directory_service_sync_pargs() throw();
  const std::string* path;
  const std::string* backing_path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_sync_result__isset {
  _directory_service_sync_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_sync_result__isset;

class directory_service_sync_result {
 public:

  directory_service_sync_result(const directory_service_sync_result&);
  directory_service_sync_result& operator=(const directory_service_sync_result&);
  directory_service_sync_result() {
  }

  virtual ~directory_service_sync_result() throw();
  directory_service_exception ex;

  _directory_service_sync_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_sync_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_sync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_sync_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_sync_presult__isset {
  _directory_service_sync_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_sync_presult__isset;

class directory_service_sync_presult {
 public:


  virtual ~directory_service_sync_presult() throw();
  directory_service_exception ex;

  _directory_service_sync_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_dump_args__isset {
  _directory_service_dump_args__isset() : path(false), backing_path(false) {}
  bool path :1;
  bool backing_path :1;
} _directory_service_dump_args__isset;

class directory_service_dump_args {
 public:

  directory_service_dump_args(const directory_service_dump_args&);
  directory_service_dump_args& operator=(const directory_service_dump_args&);
  directory_service_dump_args() : path(), backing_path() {
  }

  virtual ~directory_service_dump_args() throw();
  std::string path;
  std::string backing_path;

  _directory_service_dump_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_backing_path(const std::string& val);

  bool operator == (const directory_service_dump_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(backing_path == rhs.backing_path))
      return false;
    return true;
  }
  bool operator != (const directory_service_dump_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_dump_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_dump_pargs {
 public:


  virtual ~directory_service_dump_pargs() throw();
  const std::string* path;
  const std::string* backing_path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_dump_result__isset {
  _directory_service_dump_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_dump_result__isset;

class directory_service_dump_result {
 public:

  directory_service_dump_result(const directory_service_dump_result&);
  directory_service_dump_result& operator=(const directory_service_dump_result&);
  directory_service_dump_result() {
  }

  virtual ~directory_service_dump_result() throw();
  directory_service_exception ex;

  _directory_service_dump_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_dump_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_dump_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_dump_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_dump_presult__isset {
  _directory_service_dump_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_dump_presult__isset;

class directory_service_dump_presult {
 public:


  virtual ~directory_service_dump_presult() throw();
  directory_service_exception ex;

  _directory_service_dump_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_load_args__isset {
  _directory_service_load_args__isset() : path(false), backing_path(false) {}
  bool path :1;
  bool backing_path :1;
} _directory_service_load_args__isset;

class directory_service_load_args {
 public:

  directory_service_load_args(const directory_service_load_args&);
  directory_service_load_args& operator=(const directory_service_load_args&);
  directory_service_load_args() : path(), backing_path() {
  }

  virtual ~directory_service_load_args() throw();
  std::string path;
  std::string backing_path;

  _directory_service_load_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_backing_path(const std::string& val);

  bool operator == (const directory_service_load_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(backing_path == rhs.backing_path))
      return false;
    return true;
  }
  bool operator != (const directory_service_load_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_load_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_load_pargs {
 public:


  virtual ~directory_service_load_pargs() throw();
  const std::string* path;
  const std::string* backing_path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_load_result__isset {
  _directory_service_load_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_load_result__isset;

class directory_service_load_result {
 public:

  directory_service_load_result(const directory_service_load_result&);
  directory_service_load_result& operator=(const directory_service_load_result&);
  directory_service_load_result() {
  }

  virtual ~directory_service_load_result() throw();
  directory_service_exception ex;

  _directory_service_load_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_load_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_load_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_load_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_load_presult__isset {
  _directory_service_load_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_load_presult__isset;

class directory_service_load_presult {
 public:


  virtual ~directory_service_load_presult() throw();
  directory_service_exception ex;

  _directory_service_load_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_rename_args__isset {
  _directory_service_rename_args__isset() : old_path(false), new_path(false) {}
  bool old_path :1;
  bool new_path :1;
} _directory_service_rename_args__isset;

class directory_service_rename_args {
 public:

  directory_service_rename_args(const directory_service_rename_args&);
  directory_service_rename_args& operator=(const directory_service_rename_args&);
  directory_service_rename_args() : old_path(), new_path() {
  }

  virtual ~directory_service_rename_args() throw();
  std::string old_path;
  std::string new_path;

  _directory_service_rename_args__isset __isset;

  void __set_old_path(const std::string& val);

  void __set_new_path(const std::string& val);

  bool operator == (const directory_service_rename_args & rhs) const
  {
    if (!(old_path == rhs.old_path))
      return false;
    if (!(new_path == rhs.new_path))
      return false;
    return true;
  }
  bool operator != (const directory_service_rename_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_rename_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_rename_pargs {
 public:


  virtual ~directory_service_rename_pargs() throw();
  const std::string* old_path;
  const std::string* new_path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_rename_result__isset {
  _directory_service_rename_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_rename_result__isset;

class directory_service_rename_result {
 public:

  directory_service_rename_result(const directory_service_rename_result&);
  directory_service_rename_result& operator=(const directory_service_rename_result&);
  directory_service_rename_result() {
  }

  virtual ~directory_service_rename_result() throw();
  directory_service_exception ex;

  _directory_service_rename_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_rename_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_rename_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_rename_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_rename_presult__isset {
  _directory_service_rename_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_rename_presult__isset;

class directory_service_rename_presult {
 public:


  virtual ~directory_service_rename_presult() throw();
  directory_service_exception ex;

  _directory_service_rename_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_status_args__isset {
  _directory_service_status_args__isset() : path(false) {}
  bool path :1;
} _directory_service_status_args__isset;

class directory_service_status_args {
 public:

  directory_service_status_args(const directory_service_status_args&);
  directory_service_status_args& operator=(const directory_service_status_args&);
  directory_service_status_args() : path() {
  }

  virtual ~directory_service_status_args() throw();
  std::string path;

  _directory_service_status_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_status_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_status_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_status_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_status_pargs {
 public:


  virtual ~directory_service_status_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_status_result__isset {
  _directory_service_status_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_status_result__isset;

class directory_service_status_result {
 public:

  directory_service_status_result(const directory_service_status_result&);
  directory_service_status_result& operator=(const directory_service_status_result&);
  directory_service_status_result() {
  }

  virtual ~directory_service_status_result() throw();
  rpc_file_status success;
  directory_service_exception ex;

  _directory_service_status_result__isset __isset;

  void __set_success(const rpc_file_status& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_status_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_status_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_status_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_status_presult__isset {
  _directory_service_status_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_status_presult__isset;

class directory_service_status_presult {
 public:


  virtual ~directory_service_status_presult() throw();
  rpc_file_status* success;
  directory_service_exception ex;

  _directory_service_status_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_directory_entries_args__isset {
  _directory_service_directory_entries_args__isset() : path(false) {}
  bool path :1;
} _directory_service_directory_entries_args__isset;

class directory_service_directory_entries_args {
 public:

  directory_service_directory_entries_args(const directory_service_directory_entries_args&);
  directory_service_directory_entries_args& operator=(const directory_service_directory_entries_args&);
  directory_service_directory_entries_args() : path() {
  }

  virtual ~directory_service_directory_entries_args() throw();
  std::string path;

  _directory_service_directory_entries_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_directory_entries_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_directory_entries_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_directory_entries_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_directory_entries_pargs {
 public:


  virtual ~directory_service_directory_entries_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_directory_entries_result__isset {
  _directory_service_directory_entries_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_directory_entries_result__isset;

class directory_service_directory_entries_result {
 public:

  directory_service_directory_entries_result(const directory_service_directory_entries_result&);
  directory_service_directory_entries_result& operator=(const directory_service_directory_entries_result&);
  directory_service_directory_entries_result() {
  }

  virtual ~directory_service_directory_entries_result() throw();
  std::vector<rpc_dir_entry>  success;
  directory_service_exception ex;

  _directory_service_directory_entries_result__isset __isset;

  void __set_success(const std::vector<rpc_dir_entry> & val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_directory_entries_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_directory_entries_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_directory_entries_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_directory_entries_presult__isset {
  _directory_service_directory_entries_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_directory_entries_presult__isset;

class directory_service_directory_entries_presult {
 public:


  virtual ~directory_service_directory_entries_presult() throw();
  std::vector<rpc_dir_entry> * success;
  directory_service_exception ex;

  _directory_service_directory_entries_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_recursive_directory_entries_args__isset {
  _directory_service_recursive_directory_entries_args__isset() : path(false) {}
  bool path :1;
} _directory_service_recursive_directory_entries_args__isset;

class directory_service_recursive_directory_entries_args {
 public:

  directory_service_recursive_directory_entries_args(const directory_service_recursive_directory_entries_args&);
  directory_service_recursive_directory_entries_args& operator=(const directory_service_recursive_directory_entries_args&);
  directory_service_recursive_directory_entries_args() : path() {
  }

  virtual ~directory_service_recursive_directory_entries_args() throw();
  std::string path;

  _directory_service_recursive_directory_entries_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_recursive_directory_entries_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_recursive_directory_entries_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_recursive_directory_entries_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_recursive_directory_entries_pargs {
 public:


  virtual ~directory_service_recursive_directory_entries_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_recursive_directory_entries_result__isset {
  _directory_service_recursive_directory_entries_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_recursive_directory_entries_result__isset;

class directory_service_recursive_directory_entries_result {
 public:

  directory_service_recursive_directory_entries_result(const directory_service_recursive_directory_entries_result&);
  directory_service_recursive_directory_entries_result& operator=(const directory_service_recursive_directory_entries_result&);
  directory_service_recursive_directory_entries_result() {
  }

  virtual ~directory_service_recursive_directory_entries_result() throw();
  std::vector<rpc_dir_entry>  success;
  directory_service_exception ex;

  _directory_service_recursive_directory_entries_result__isset __isset;

  void __set_success(const std::vector<rpc_dir_entry> & val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_recursive_directory_entries_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_recursive_directory_entries_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_recursive_directory_entries_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_recursive_directory_entries_presult__isset {
  _directory_service_recursive_directory_entries_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_recursive_directory_entries_presult__isset;

class directory_service_recursive_directory_entries_presult {
 public:


  virtual ~directory_service_recursive_directory_entries_presult() throw();
  std::vector<rpc_dir_entry> * success;
  directory_service_exception ex;

  _directory_service_recursive_directory_entries_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_dstatus_args__isset {
  _directory_service_dstatus_args__isset() : path(false) {}
  bool path :1;
} _directory_service_dstatus_args__isset;

class directory_service_dstatus_args {
 public:

  directory_service_dstatus_args(const directory_service_dstatus_args&);
  directory_service_dstatus_args& operator=(const directory_service_dstatus_args&);
  directory_service_dstatus_args() : path() {
  }

  virtual ~directory_service_dstatus_args() throw();
  std::string path;

  _directory_service_dstatus_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_dstatus_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_dstatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_dstatus_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_dstatus_pargs {
 public:


  virtual ~directory_service_dstatus_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_dstatus_result__isset {
  _directory_service_dstatus_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_dstatus_result__isset;

class directory_service_dstatus_result {
 public:

  directory_service_dstatus_result(const directory_service_dstatus_result&);
  directory_service_dstatus_result& operator=(const directory_service_dstatus_result&);
  directory_service_dstatus_result() {
  }

  virtual ~directory_service_dstatus_result() throw();
  rpc_data_status success;
  directory_service_exception ex;

  _directory_service_dstatus_result__isset __isset;

  void __set_success(const rpc_data_status& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_dstatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_dstatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_dstatus_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_dstatus_presult__isset {
  _directory_service_dstatus_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_dstatus_presult__isset;

class directory_service_dstatus_presult {
 public:


  virtual ~directory_service_dstatus_presult() throw();
  rpc_data_status* success;
  directory_service_exception ex;

  _directory_service_dstatus_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_add_tags_args__isset {
  _directory_service_add_tags_args__isset() : path(false), tags(false) {}
  bool path :1;
  bool tags :1;
} _directory_service_add_tags_args__isset;

class directory_service_add_tags_args {
 public:

  directory_service_add_tags_args(const directory_service_add_tags_args&);
  directory_service_add_tags_args& operator=(const directory_service_add_tags_args&);
  directory_service_add_tags_args() : path() {
  }

  virtual ~directory_service_add_tags_args() throw();
  std::string path;
  std::map<std::string, std::string>  tags;

  _directory_service_add_tags_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_tags(const std::map<std::string, std::string> & val);

  bool operator == (const directory_service_add_tags_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_tags_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_tags_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_add_tags_pargs {
 public:


  virtual ~directory_service_add_tags_pargs() throw();
  const std::string* path;
  const std::map<std::string, std::string> * tags;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_tags_result__isset {
  _directory_service_add_tags_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_add_tags_result__isset;

class directory_service_add_tags_result {
 public:

  directory_service_add_tags_result(const directory_service_add_tags_result&);
  directory_service_add_tags_result& operator=(const directory_service_add_tags_result&);
  directory_service_add_tags_result() {
  }

  virtual ~directory_service_add_tags_result() throw();
  directory_service_exception ex;

  _directory_service_add_tags_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_add_tags_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_tags_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_tags_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_tags_presult__isset {
  _directory_service_add_tags_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_add_tags_presult__isset;

class directory_service_add_tags_presult {
 public:


  virtual ~directory_service_add_tags_presult() throw();
  directory_service_exception ex;

  _directory_service_add_tags_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_is_regular_file_args__isset {
  _directory_service_is_regular_file_args__isset() : path(false) {}
  bool path :1;
} _directory_service_is_regular_file_args__isset;

class directory_service_is_regular_file_args {
 public:

  directory_service_is_regular_file_args(const directory_service_is_regular_file_args&);
  directory_service_is_regular_file_args& operator=(const directory_service_is_regular_file_args&);
  directory_service_is_regular_file_args() : path() {
  }

  virtual ~directory_service_is_regular_file_args() throw();
  std::string path;

  _directory_service_is_regular_file_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_is_regular_file_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_is_regular_file_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_is_regular_file_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_is_regular_file_pargs {
 public:


  virtual ~directory_service_is_regular_file_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_is_regular_file_result__isset {
  _directory_service_is_regular_file_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_is_regular_file_result__isset;

class directory_service_is_regular_file_result {
 public:

  directory_service_is_regular_file_result(const directory_service_is_regular_file_result&);
  directory_service_is_regular_file_result& operator=(const directory_service_is_regular_file_result&);
  directory_service_is_regular_file_result() : success(0) {
  }

  virtual ~directory_service_is_regular_file_result() throw();
  bool success;
  directory_service_exception ex;

  _directory_service_is_regular_file_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_is_regular_file_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_is_regular_file_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_is_regular_file_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_is_regular_file_presult__isset {
  _directory_service_is_regular_file_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_is_regular_file_presult__isset;

class directory_service_is_regular_file_presult {
 public:


  virtual ~directory_service_is_regular_file_presult() throw();
  bool* success;
  directory_service_exception ex;

  _directory_service_is_regular_file_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_is_directory_args__isset {
  _directory_service_is_directory_args__isset() : path(false) {}
  bool path :1;
} _directory_service_is_directory_args__isset;

class directory_service_is_directory_args {
 public:

  directory_service_is_directory_args(const directory_service_is_directory_args&);
  directory_service_is_directory_args& operator=(const directory_service_is_directory_args&);
  directory_service_is_directory_args() : path() {
  }

  virtual ~directory_service_is_directory_args() throw();
  std::string path;

  _directory_service_is_directory_args__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const directory_service_is_directory_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const directory_service_is_directory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_is_directory_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_is_directory_pargs {
 public:


  virtual ~directory_service_is_directory_pargs() throw();
  const std::string* path;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_is_directory_result__isset {
  _directory_service_is_directory_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_is_directory_result__isset;

class directory_service_is_directory_result {
 public:

  directory_service_is_directory_result(const directory_service_is_directory_result&);
  directory_service_is_directory_result& operator=(const directory_service_is_directory_result&);
  directory_service_is_directory_result() : success(0) {
  }

  virtual ~directory_service_is_directory_result() throw();
  bool success;
  directory_service_exception ex;

  _directory_service_is_directory_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_is_directory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_is_directory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_is_directory_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_is_directory_presult__isset {
  _directory_service_is_directory_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_is_directory_presult__isset;

class directory_service_is_directory_presult {
 public:


  virtual ~directory_service_is_directory_presult() throw();
  bool* success;
  directory_service_exception ex;

  _directory_service_is_directory_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_reslove_failures_args__isset {
  _directory_service_reslove_failures_args__isset() : path(false), chain(false) {}
  bool path :1;
  bool chain :1;
} _directory_service_reslove_failures_args__isset;

class directory_service_reslove_failures_args {
 public:

  directory_service_reslove_failures_args(const directory_service_reslove_failures_args&);
  directory_service_reslove_failures_args& operator=(const directory_service_reslove_failures_args&);
  directory_service_reslove_failures_args() : path() {
  }

  virtual ~directory_service_reslove_failures_args() throw();
  std::string path;
  rpc_replica_chain chain;

  _directory_service_reslove_failures_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_chain(const rpc_replica_chain& val);

  bool operator == (const directory_service_reslove_failures_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(chain == rhs.chain))
      return false;
    return true;
  }
  bool operator != (const directory_service_reslove_failures_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_reslove_failures_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_reslove_failures_pargs {
 public:


  virtual ~directory_service_reslove_failures_pargs() throw();
  const std::string* path;
  const rpc_replica_chain* chain;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_reslove_failures_result__isset {
  _directory_service_reslove_failures_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_reslove_failures_result__isset;

class directory_service_reslove_failures_result {
 public:

  directory_service_reslove_failures_result(const directory_service_reslove_failures_result&);
  directory_service_reslove_failures_result& operator=(const directory_service_reslove_failures_result&);
  directory_service_reslove_failures_result() {
  }

  virtual ~directory_service_reslove_failures_result() throw();
  rpc_replica_chain success;
  directory_service_exception ex;

  _directory_service_reslove_failures_result__isset __isset;

  void __set_success(const rpc_replica_chain& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_reslove_failures_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_reslove_failures_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_reslove_failures_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_reslove_failures_presult__isset {
  _directory_service_reslove_failures_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_reslove_failures_presult__isset;

class directory_service_reslove_failures_presult {
 public:


  virtual ~directory_service_reslove_failures_presult() throw();
  rpc_replica_chain* success;
  directory_service_exception ex;

  _directory_service_reslove_failures_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_add_replica_to_chain_args__isset {
  _directory_service_add_replica_to_chain_args__isset() : path(false), chain(false) {}
  bool path :1;
  bool chain :1;
} _directory_service_add_replica_to_chain_args__isset;

class directory_service_add_replica_to_chain_args {
 public:

  directory_service_add_replica_to_chain_args(const directory_service_add_replica_to_chain_args&);
  directory_service_add_replica_to_chain_args& operator=(const directory_service_add_replica_to_chain_args&);
  directory_service_add_replica_to_chain_args() : path() {
  }

  virtual ~directory_service_add_replica_to_chain_args() throw();
  std::string path;
  rpc_replica_chain chain;

  _directory_service_add_replica_to_chain_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_chain(const rpc_replica_chain& val);

  bool operator == (const directory_service_add_replica_to_chain_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(chain == rhs.chain))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_replica_to_chain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_replica_to_chain_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_add_replica_to_chain_pargs {
 public:


  virtual ~directory_service_add_replica_to_chain_pargs() throw();
  const std::string* path;
  const rpc_replica_chain* chain;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_replica_to_chain_result__isset {
  _directory_service_add_replica_to_chain_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_add_replica_to_chain_result__isset;

class directory_service_add_replica_to_chain_result {
 public:

  directory_service_add_replica_to_chain_result(const directory_service_add_replica_to_chain_result&);
  directory_service_add_replica_to_chain_result& operator=(const directory_service_add_replica_to_chain_result&);
  directory_service_add_replica_to_chain_result() {
  }

  virtual ~directory_service_add_replica_to_chain_result() throw();
  rpc_replica_chain success;
  directory_service_exception ex;

  _directory_service_add_replica_to_chain_result__isset __isset;

  void __set_success(const rpc_replica_chain& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_add_replica_to_chain_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_replica_to_chain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_replica_to_chain_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_replica_to_chain_presult__isset {
  _directory_service_add_replica_to_chain_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_add_replica_to_chain_presult__isset;

class directory_service_add_replica_to_chain_presult {
 public:


  virtual ~directory_service_add_replica_to_chain_presult() throw();
  rpc_replica_chain* success;
  directory_service_exception ex;

  _directory_service_add_replica_to_chain_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_add_data_block_args__isset {
  _directory_service_add_data_block_args__isset() : path(false), partition_name(false), partition_metadata(false) {}
  bool path :1;
  bool partition_name :1;
  bool partition_metadata :1;
} _directory_service_add_data_block_args__isset;

class directory_service_add_data_block_args {
 public:

  directory_service_add_data_block_args(const directory_service_add_data_block_args&);
  directory_service_add_data_block_args& operator=(const directory_service_add_data_block_args&);
  directory_service_add_data_block_args() : path(), partition_name(), partition_metadata() {
  }

  virtual ~directory_service_add_data_block_args() throw();
  std::string path;
  std::string partition_name;
  std::string partition_metadata;

  _directory_service_add_data_block_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_partition_name(const std::string& val);

  void __set_partition_metadata(const std::string& val);

  bool operator == (const directory_service_add_data_block_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(partition_name == rhs.partition_name))
      return false;
    if (!(partition_metadata == rhs.partition_metadata))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_data_block_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_data_block_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_add_data_block_pargs {
 public:


  virtual ~directory_service_add_data_block_pargs() throw();
  const std::string* path;
  const std::string* partition_name;
  const std::string* partition_metadata;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_data_block_result__isset {
  _directory_service_add_data_block_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_add_data_block_result__isset;

class directory_service_add_data_block_result {
 public:

  directory_service_add_data_block_result(const directory_service_add_data_block_result&);
  directory_service_add_data_block_result& operator=(const directory_service_add_data_block_result&);
  directory_service_add_data_block_result() {
  }

  virtual ~directory_service_add_data_block_result() throw();
  rpc_replica_chain success;
  directory_service_exception ex;

  _directory_service_add_data_block_result__isset __isset;

  void __set_success(const rpc_replica_chain& val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_add_data_block_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_add_data_block_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_add_data_block_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_add_data_block_presult__isset {
  _directory_service_add_data_block_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_add_data_block_presult__isset;

class directory_service_add_data_block_presult {
 public:


  virtual ~directory_service_add_data_block_presult() throw();
  rpc_replica_chain* success;
  directory_service_exception ex;

  _directory_service_add_data_block_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_remove_data_block_args__isset {
  _directory_service_remove_data_block_args__isset() : path(false), partition_name(false) {}
  bool path :1;
  bool partition_name :1;
} _directory_service_remove_data_block_args__isset;

class directory_service_remove_data_block_args {
 public:

  directory_service_remove_data_block_args(const directory_service_remove_data_block_args&);
  directory_service_remove_data_block_args& operator=(const directory_service_remove_data_block_args&);
  directory_service_remove_data_block_args() : path(), partition_name() {
  }

  virtual ~directory_service_remove_data_block_args() throw();
  std::string path;
  std::string partition_name;

  _directory_service_remove_data_block_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_partition_name(const std::string& val);

  bool operator == (const directory_service_remove_data_block_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(partition_name == rhs.partition_name))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_data_block_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_data_block_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_remove_data_block_pargs {
 public:


  virtual ~directory_service_remove_data_block_pargs() throw();
  const std::string* path;
  const std::string* partition_name;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_data_block_result__isset {
  _directory_service_remove_data_block_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_data_block_result__isset;

class directory_service_remove_data_block_result {
 public:

  directory_service_remove_data_block_result(const directory_service_remove_data_block_result&);
  directory_service_remove_data_block_result& operator=(const directory_service_remove_data_block_result&);
  directory_service_remove_data_block_result() {
  }

  virtual ~directory_service_remove_data_block_result() throw();
  directory_service_exception ex;

  _directory_service_remove_data_block_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_remove_data_block_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_remove_data_block_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_remove_data_block_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_remove_data_block_presult__isset {
  _directory_service_remove_data_block_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_remove_data_block_presult__isset;

class directory_service_remove_data_block_presult {
 public:


  virtual ~directory_service_remove_data_block_presult() throw();
  directory_service_exception ex;

  _directory_service_remove_data_block_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_request_partition_data_update_args__isset {
  _directory_service_request_partition_data_update_args__isset() : path(false), old_partition_name(false), new_partition_name(false), partition_metadata(false) {}
  bool path :1;
  bool old_partition_name :1;
  bool new_partition_name :1;
  bool partition_metadata :1;
} _directory_service_request_partition_data_update_args__isset;

class directory_service_request_partition_data_update_args {
 public:

  directory_service_request_partition_data_update_args(const directory_service_request_partition_data_update_args&);
  directory_service_request_partition_data_update_args& operator=(const directory_service_request_partition_data_update_args&);
  directory_service_request_partition_data_update_args() : path(), old_partition_name(), new_partition_name(), partition_metadata() {
  }

  virtual ~directory_service_request_partition_data_update_args() throw();
  std::string path;
  std::string old_partition_name;
  std::string new_partition_name;
  std::string partition_metadata;

  _directory_service_request_partition_data_update_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_old_partition_name(const std::string& val);

  void __set_new_partition_name(const std::string& val);

  void __set_partition_metadata(const std::string& val);

  bool operator == (const directory_service_request_partition_data_update_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(old_partition_name == rhs.old_partition_name))
      return false;
    if (!(new_partition_name == rhs.new_partition_name))
      return false;
    if (!(partition_metadata == rhs.partition_metadata))
      return false;
    return true;
  }
  bool operator != (const directory_service_request_partition_data_update_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_request_partition_data_update_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_request_partition_data_update_pargs {
 public:


  virtual ~directory_service_request_partition_data_update_pargs() throw();
  const std::string* path;
  const std::string* old_partition_name;
  const std::string* new_partition_name;
  const std::string* partition_metadata;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_request_partition_data_update_result__isset {
  _directory_service_request_partition_data_update_result__isset() : ex(false) {}
  bool ex :1;
} _directory_service_request_partition_data_update_result__isset;

class directory_service_request_partition_data_update_result {
 public:

  directory_service_request_partition_data_update_result(const directory_service_request_partition_data_update_result&);
  directory_service_request_partition_data_update_result& operator=(const directory_service_request_partition_data_update_result&);
  directory_service_request_partition_data_update_result() {
  }

  virtual ~directory_service_request_partition_data_update_result() throw();
  directory_service_exception ex;

  _directory_service_request_partition_data_update_result__isset __isset;

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_request_partition_data_update_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_request_partition_data_update_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_request_partition_data_update_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_request_partition_data_update_presult__isset {
  _directory_service_request_partition_data_update_presult__isset() : ex(false) {}
  bool ex :1;
} _directory_service_request_partition_data_update_presult__isset;

class directory_service_request_partition_data_update_presult {
 public:


  virtual ~directory_service_request_partition_data_update_presult() throw();
  directory_service_exception ex;

  _directory_service_request_partition_data_update_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

typedef struct _directory_service_get_storage_capacity_args__isset {
  _directory_service_get_storage_capacity_args__isset() : path(false), partition_name(false) {}
  bool path :1;
  bool partition_name :1;
} _directory_service_get_storage_capacity_args__isset;

class directory_service_get_storage_capacity_args {
 public:

  directory_service_get_storage_capacity_args(const directory_service_get_storage_capacity_args&);
  directory_service_get_storage_capacity_args& operator=(const directory_service_get_storage_capacity_args&);
  directory_service_get_storage_capacity_args() : path(), partition_name() {
  }

  virtual ~directory_service_get_storage_capacity_args() throw();
  std::string path;
  std::string partition_name;

  _directory_service_get_storage_capacity_args__isset __isset;

  void __set_path(const std::string& val);

  void __set_partition_name(const std::string& val);

  bool operator == (const directory_service_get_storage_capacity_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(partition_name == rhs.partition_name))
      return false;
    return true;
  }
  bool operator != (const directory_service_get_storage_capacity_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_get_storage_capacity_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};


class directory_service_get_storage_capacity_pargs {
 public:


  virtual ~directory_service_get_storage_capacity_pargs() throw();
  const std::string* path;
  const std::string* partition_name;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_get_storage_capacity_result__isset {
  _directory_service_get_storage_capacity_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_get_storage_capacity_result__isset;

class directory_service_get_storage_capacity_result {
 public:

  directory_service_get_storage_capacity_result(const directory_service_get_storage_capacity_result&);
  directory_service_get_storage_capacity_result& operator=(const directory_service_get_storage_capacity_result&);
  directory_service_get_storage_capacity_result() : success(0) {
  }

  virtual ~directory_service_get_storage_capacity_result() throw();
  int64_t success;
  directory_service_exception ex;

  _directory_service_get_storage_capacity_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_ex(const directory_service_exception& val);

  bool operator == (const directory_service_get_storage_capacity_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const directory_service_get_storage_capacity_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const directory_service_get_storage_capacity_result & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

typedef struct _directory_service_get_storage_capacity_presult__isset {
  _directory_service_get_storage_capacity_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _directory_service_get_storage_capacity_presult__isset;

class directory_service_get_storage_capacity_presult {
 public:


  virtual ~directory_service_get_storage_capacity_presult() throw();
  int64_t* success;
  directory_service_exception ex;

  _directory_service_get_storage_capacity_presult__isset __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);

};

template <class Protocol_>
class directory_serviceClientT : virtual public directory_serviceIf {
 public:
  directory_serviceClientT(apache::thrift::stdcxx::shared_ptr< Protocol_> prot) {
    setProtocolT(prot);
  }
  directory_serviceClientT(apache::thrift::stdcxx::shared_ptr< Protocol_> iprot, apache::thrift::stdcxx::shared_ptr< Protocol_> oprot) {
    setProtocolT(iprot,oprot);
  }
 private:
  void setProtocolT(apache::thrift::stdcxx::shared_ptr< Protocol_> prot) {
  setProtocolT(prot,prot);
  }
  void setProtocolT(apache::thrift::stdcxx::shared_ptr< Protocol_> iprot, apache::thrift::stdcxx::shared_ptr< Protocol_> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return this->piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return this->poprot_;
  }
  void create_directory(const std::string& path);
  void send_create_directory(const std::string& path);
  void recv_create_directory();
  void create_directories(const std::string& path);
  void send_create_directories(const std::string& path);
  void recv_create_directories();
  void open(rpc_data_status& _return, const std::string& path);
  void send_open(const std::string& path);
  void recv_open(rpc_data_status& _return);
  void create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void send_create(const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void recv_create(rpc_data_status& _return);
  void open_or_create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void send_open_or_create(const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void recv_open_or_create(rpc_data_status& _return);
  bool exists(const std::string& path);
  void send_exists(const std::string& path);
  bool recv_exists();
  int64_t last_write_time(const std::string& path);
  void send_last_write_time(const std::string& path);
  int64_t recv_last_write_time();
  void set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts);
  void send_set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts);
  void recv_set_permissions();
  rpc_perms get_permissions(const std::string& path);
  void send_get_permissions(const std::string& path);
  rpc_perms recv_get_permissions();
  void remove(const std::string& path);
  void send_remove(const std::string& path);
  void recv_remove();
  void remove_all(const std::string& path);
  void send_remove_all(const std::string& path);
  void recv_remove_all();
  void sync(const std::string& path, const std::string& backing_path);
  void send_sync(const std::string& path, const std::string& backing_path);
  void recv_sync();
  void dump(const std::string& path, const std::string& backing_path);
  void send_dump(const std::string& path, const std::string& backing_path);
  void recv_dump();
  void load(const std::string& path, const std::string& backing_path);
  void send_load(const std::string& path, const std::string& backing_path);
  void recv_load();
  void rename(const std::string& old_path, const std::string& new_path);
  void send_rename(const std::string& old_path, const std::string& new_path);
  void recv_rename();
  void status(rpc_file_status& _return, const std::string& path);
  void send_status(const std::string& path);
  void recv_status(rpc_file_status& _return);
  void directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path);
  void send_directory_entries(const std::string& path);
  void recv_directory_entries(std::vector<rpc_dir_entry> & _return);
  void recursive_directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path);
  void send_recursive_directory_entries(const std::string& path);
  void recv_recursive_directory_entries(std::vector<rpc_dir_entry> & _return);
  void dstatus(rpc_data_status& _return, const std::string& path);
  void send_dstatus(const std::string& path);
  void recv_dstatus(rpc_data_status& _return);
  void add_tags(const std::string& path, const std::map<std::string, std::string> & tags);
  void send_add_tags(const std::string& path, const std::map<std::string, std::string> & tags);
  void recv_add_tags();
  bool is_regular_file(const std::string& path);
  void send_is_regular_file(const std::string& path);
  bool recv_is_regular_file();
  bool is_directory(const std::string& path);
  void send_is_directory(const std::string& path);
  bool recv_is_directory();
  void reslove_failures(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain);
  void send_reslove_failures(const std::string& path, const rpc_replica_chain& chain);
  void recv_reslove_failures(rpc_replica_chain& _return);
  void add_replica_to_chain(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain);
  void send_add_replica_to_chain(const std::string& path, const rpc_replica_chain& chain);
  void recv_add_replica_to_chain(rpc_replica_chain& _return);
  void add_data_block(rpc_replica_chain& _return, const std::string& path, const std::string& partition_name, const std::string& partition_metadata);
  void send_add_data_block(const std::string& path, const std::string& partition_name, const std::string& partition_metadata);
  void recv_add_data_block(rpc_replica_chain& _return);
  void remove_data_block(const std::string& path, const std::string& partition_name);
  void send_remove_data_block(const std::string& path, const std::string& partition_name);
  void recv_remove_data_block();
  void request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata);
  void send_request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata);
  void recv_request_partition_data_update();
  int64_t get_storage_capacity(const std::string& path, const std::string& partition_name);
  void send_get_storage_capacity(const std::string& path, const std::string& partition_name);
  int64_t recv_get_storage_capacity();
 protected:
  apache::thrift::stdcxx::shared_ptr< Protocol_> piprot_;
  apache::thrift::stdcxx::shared_ptr< Protocol_> poprot_;
  Protocol_* iprot_;
  Protocol_* oprot_;
};

typedef directory_serviceClientT< ::apache::thrift::protocol::TProtocol> directory_serviceClient;

template <class Protocol_>
class directory_serviceProcessorT : public ::apache::thrift::TDispatchProcessorT<Protocol_> {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<directory_serviceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
  virtual bool dispatchCallTemplated(Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (directory_serviceProcessorT::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef void (directory_serviceProcessorT::*SpecializedProcessFunction)(int32_t, Protocol_*, Protocol_*, void*);
  struct ProcessFunctions {
    ProcessFunction generic;
    SpecializedProcessFunction specialized;
    ProcessFunctions(ProcessFunction g, SpecializedProcessFunction s) :
      generic(g),
      specialized(s) {}
    ProcessFunctions() : generic(NULL), specialized(NULL) {}
  };
  typedef std::map<std::string, ProcessFunctions> ProcessMap;
  ProcessMap processMap_;
  void process_create_directory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_directory(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_create_directories(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_directories(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_open_or_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_or_create(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_exists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exists(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_last_write_time(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_last_write_time(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_set_permissions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_permissions(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_get_permissions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_permissions(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_remove(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_remove_all(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove_all(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_sync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_sync(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_dump(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_dump(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_load(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_load(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_rename(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rename(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_status(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_status(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_directory_entries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_directory_entries(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_recursive_directory_entries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_recursive_directory_entries(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_dstatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_dstatus(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_add_tags(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add_tags(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_is_regular_file(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_is_regular_file(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_is_directory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_is_directory(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_reslove_failures(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_reslove_failures(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_add_replica_to_chain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add_replica_to_chain(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_add_data_block(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add_data_block(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_remove_data_block(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove_data_block(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_request_partition_data_update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_request_partition_data_update(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
  void process_get_storage_capacity(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_storage_capacity(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext);
 public:
  directory_serviceProcessorT(::apache::thrift::stdcxx::shared_ptr<directory_serviceIf> iface) :
    iface_(iface) {
    processMap_["create_directory"] = ProcessFunctions(
      &directory_serviceProcessorT::process_create_directory,
      &directory_serviceProcessorT::process_create_directory);
    processMap_["create_directories"] = ProcessFunctions(
      &directory_serviceProcessorT::process_create_directories,
      &directory_serviceProcessorT::process_create_directories);
    processMap_["open"] = ProcessFunctions(
      &directory_serviceProcessorT::process_open,
      &directory_serviceProcessorT::process_open);
    processMap_["create"] = ProcessFunctions(
      &directory_serviceProcessorT::process_create,
      &directory_serviceProcessorT::process_create);
    processMap_["open_or_create"] = ProcessFunctions(
      &directory_serviceProcessorT::process_open_or_create,
      &directory_serviceProcessorT::process_open_or_create);
    processMap_["exists"] = ProcessFunctions(
      &directory_serviceProcessorT::process_exists,
      &directory_serviceProcessorT::process_exists);
    processMap_["last_write_time"] = ProcessFunctions(
      &directory_serviceProcessorT::process_last_write_time,
      &directory_serviceProcessorT::process_last_write_time);
    processMap_["set_permissions"] = ProcessFunctions(
      &directory_serviceProcessorT::process_set_permissions,
      &directory_serviceProcessorT::process_set_permissions);
    processMap_["get_permissions"] = ProcessFunctions(
      &directory_serviceProcessorT::process_get_permissions,
      &directory_serviceProcessorT::process_get_permissions);
    processMap_["remove"] = ProcessFunctions(
      &directory_serviceProcessorT::process_remove,
      &directory_serviceProcessorT::process_remove);
    processMap_["remove_all"] = ProcessFunctions(
      &directory_serviceProcessorT::process_remove_all,
      &directory_serviceProcessorT::process_remove_all);
    processMap_["sync"] = ProcessFunctions(
      &directory_serviceProcessorT::process_sync,
      &directory_serviceProcessorT::process_sync);
    processMap_["dump"] = ProcessFunctions(
      &directory_serviceProcessorT::process_dump,
      &directory_serviceProcessorT::process_dump);
    processMap_["load"] = ProcessFunctions(
      &directory_serviceProcessorT::process_load,
      &directory_serviceProcessorT::process_load);
    processMap_["rename"] = ProcessFunctions(
      &directory_serviceProcessorT::process_rename,
      &directory_serviceProcessorT::process_rename);
    processMap_["status"] = ProcessFunctions(
      &directory_serviceProcessorT::process_status,
      &directory_serviceProcessorT::process_status);
    processMap_["directory_entries"] = ProcessFunctions(
      &directory_serviceProcessorT::process_directory_entries,
      &directory_serviceProcessorT::process_directory_entries);
    processMap_["recursive_directory_entries"] = ProcessFunctions(
      &directory_serviceProcessorT::process_recursive_directory_entries,
      &directory_serviceProcessorT::process_recursive_directory_entries);
    processMap_["dstatus"] = ProcessFunctions(
      &directory_serviceProcessorT::process_dstatus,
      &directory_serviceProcessorT::process_dstatus);
    processMap_["add_tags"] = ProcessFunctions(
      &directory_serviceProcessorT::process_add_tags,
      &directory_serviceProcessorT::process_add_tags);
    processMap_["is_regular_file"] = ProcessFunctions(
      &directory_serviceProcessorT::process_is_regular_file,
      &directory_serviceProcessorT::process_is_regular_file);
    processMap_["is_directory"] = ProcessFunctions(
      &directory_serviceProcessorT::process_is_directory,
      &directory_serviceProcessorT::process_is_directory);
    processMap_["reslove_failures"] = ProcessFunctions(
      &directory_serviceProcessorT::process_reslove_failures,
      &directory_serviceProcessorT::process_reslove_failures);
    processMap_["add_replica_to_chain"] = ProcessFunctions(
      &directory_serviceProcessorT::process_add_replica_to_chain,
      &directory_serviceProcessorT::process_add_replica_to_chain);
    processMap_["add_data_block"] = ProcessFunctions(
      &directory_serviceProcessorT::process_add_data_block,
      &directory_serviceProcessorT::process_add_data_block);
    processMap_["remove_data_block"] = ProcessFunctions(
      &directory_serviceProcessorT::process_remove_data_block,
      &directory_serviceProcessorT::process_remove_data_block);
    processMap_["request_partition_data_update"] = ProcessFunctions(
      &directory_serviceProcessorT::process_request_partition_data_update,
      &directory_serviceProcessorT::process_request_partition_data_update);
    processMap_["get_storage_capacity"] = ProcessFunctions(
      &directory_serviceProcessorT::process_get_storage_capacity,
      &directory_serviceProcessorT::process_get_storage_capacity);
  }

  virtual ~directory_serviceProcessorT() {}
};

typedef directory_serviceProcessorT< ::apache::thrift::protocol::TDummyProtocol > directory_serviceProcessor;

template <class Protocol_>
class directory_serviceProcessorFactoryT : public ::apache::thrift::TProcessorFactory {
 public:
  directory_serviceProcessorFactoryT(const ::apache::thrift::stdcxx::shared_ptr< directory_serviceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< directory_serviceIfFactory > handlerFactory_;
};

typedef directory_serviceProcessorFactoryT< ::apache::thrift::protocol::TDummyProtocol > directory_serviceProcessorFactory;

class directory_serviceMultiface : virtual public directory_serviceIf {
 public:
  directory_serviceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<directory_serviceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~directory_serviceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<directory_serviceIf> > ifaces_;
  directory_serviceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<directory_serviceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void create_directory(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_directory(path);
    }
    ifaces_[i]->create_directory(path);
  }

  void create_directories(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_directories(path);
    }
    ifaces_[i]->create_directories(path);
  }

  void open(rpc_data_status& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open(_return, path);
    }
    ifaces_[i]->open(_return, path);
    return;
  }

  void create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create(_return, path, type, backing_path, num_blocks, chain_length, flags, permissions, block_ids, block_metadata, tags);
    }
    ifaces_[i]->create(_return, path, type, backing_path, num_blocks, chain_length, flags, permissions, block_ids, block_metadata, tags);
    return;
  }

  void open_or_create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_or_create(_return, path, type, backing_path, num_blocks, chain_length, flags, permissions, block_ids, block_metadata, tags);
    }
    ifaces_[i]->open_or_create(_return, path, type, backing_path, num_blocks, chain_length, flags, permissions, block_ids, block_metadata, tags);
    return;
  }

  bool exists(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exists(path);
    }
    return ifaces_[i]->exists(path);
  }

  int64_t last_write_time(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->last_write_time(path);
    }
    return ifaces_[i]->last_write_time(path);
  }

  void set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_permissions(path, perms, opts);
    }
    ifaces_[i]->set_permissions(path, perms, opts);
  }

  rpc_perms get_permissions(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_permissions(path);
    }
    return ifaces_[i]->get_permissions(path);
  }

  void remove(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove(path);
    }
    ifaces_[i]->remove(path);
  }

  void remove_all(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove_all(path);
    }
    ifaces_[i]->remove_all(path);
  }

  void sync(const std::string& path, const std::string& backing_path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->sync(path, backing_path);
    }
    ifaces_[i]->sync(path, backing_path);
  }

  void dump(const std::string& path, const std::string& backing_path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->dump(path, backing_path);
    }
    ifaces_[i]->dump(path, backing_path);
  }

  void load(const std::string& path, const std::string& backing_path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->load(path, backing_path);
    }
    ifaces_[i]->load(path, backing_path);
  }

  void rename(const std::string& old_path, const std::string& new_path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rename(old_path, new_path);
    }
    ifaces_[i]->rename(old_path, new_path);
  }

  void status(rpc_file_status& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->status(_return, path);
    }
    ifaces_[i]->status(_return, path);
    return;
  }

  void directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->directory_entries(_return, path);
    }
    ifaces_[i]->directory_entries(_return, path);
    return;
  }

  void recursive_directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->recursive_directory_entries(_return, path);
    }
    ifaces_[i]->recursive_directory_entries(_return, path);
    return;
  }

  void dstatus(rpc_data_status& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->dstatus(_return, path);
    }
    ifaces_[i]->dstatus(_return, path);
    return;
  }

  void add_tags(const std::string& path, const std::map<std::string, std::string> & tags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add_tags(path, tags);
    }
    ifaces_[i]->add_tags(path, tags);
  }

  bool is_regular_file(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->is_regular_file(path);
    }
    return ifaces_[i]->is_regular_file(path);
  }

  bool is_directory(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->is_directory(path);
    }
    return ifaces_[i]->is_directory(path);
  }

  void reslove_failures(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->reslove_failures(_return, path, chain);
    }
    ifaces_[i]->reslove_failures(_return, path, chain);
    return;
  }

  void add_replica_to_chain(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add_replica_to_chain(_return, path, chain);
    }
    ifaces_[i]->add_replica_to_chain(_return, path, chain);
    return;
  }

  void add_data_block(rpc_replica_chain& _return, const std::string& path, const std::string& partition_name, const std::string& partition_metadata) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add_data_block(_return, path, partition_name, partition_metadata);
    }
    ifaces_[i]->add_data_block(_return, path, partition_name, partition_metadata);
    return;
  }

  void remove_data_block(const std::string& path, const std::string& partition_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove_data_block(path, partition_name);
    }
    ifaces_[i]->remove_data_block(path, partition_name);
  }

  void request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->request_partition_data_update(path, old_partition_name, new_partition_name, partition_metadata);
    }
    ifaces_[i]->request_partition_data_update(path, old_partition_name, new_partition_name, partition_metadata);
  }

  int64_t get_storage_capacity(const std::string& path, const std::string& partition_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_storage_capacity(path, partition_name);
    }
    return ifaces_[i]->get_storage_capacity(path, partition_name);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
template <class Protocol_>
class directory_serviceConcurrentClientT : virtual public directory_serviceIf {
 public:
  directory_serviceConcurrentClientT(apache::thrift::stdcxx::shared_ptr< Protocol_> prot) {
    setProtocolT(prot);
  }
  directory_serviceConcurrentClientT(apache::thrift::stdcxx::shared_ptr< Protocol_> iprot, apache::thrift::stdcxx::shared_ptr< Protocol_> oprot) {
    setProtocolT(iprot,oprot);
  }
 private:
  void setProtocolT(apache::thrift::stdcxx::shared_ptr< Protocol_> prot) {
  setProtocolT(prot,prot);
  }
  void setProtocolT(apache::thrift::stdcxx::shared_ptr< Protocol_> iprot, apache::thrift::stdcxx::shared_ptr< Protocol_> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return this->piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return this->poprot_;
  }
  void create_directory(const std::string& path);
  int32_t send_create_directory(const std::string& path);
  void recv_create_directory(const int32_t seqid);
  void create_directories(const std::string& path);
  int32_t send_create_directories(const std::string& path);
  void recv_create_directories(const int32_t seqid);
  void open(rpc_data_status& _return, const std::string& path);
  int32_t send_open(const std::string& path);
  void recv_open(rpc_data_status& _return, const int32_t seqid);
  void create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  int32_t send_create(const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void recv_create(rpc_data_status& _return, const int32_t seqid);
  void open_or_create(rpc_data_status& _return, const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  int32_t send_open_or_create(const std::string& path, const std::string& type, const std::string& backing_path, const int32_t num_blocks, const int32_t chain_length, const int32_t flags, const int32_t permissions, const std::vector<std::string> & block_ids, const std::vector<std::string> & block_metadata, const std::map<std::string, std::string> & tags);
  void recv_open_or_create(rpc_data_status& _return, const int32_t seqid);
  bool exists(const std::string& path);
  int32_t send_exists(const std::string& path);
  bool recv_exists(const int32_t seqid);
  int64_t last_write_time(const std::string& path);
  int32_t send_last_write_time(const std::string& path);
  int64_t recv_last_write_time(const int32_t seqid);
  void set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts);
  int32_t send_set_permissions(const std::string& path, const rpc_perms perms, const rpc_perm_options opts);
  void recv_set_permissions(const int32_t seqid);
  rpc_perms get_permissions(const std::string& path);
  int32_t send_get_permissions(const std::string& path);
  rpc_perms recv_get_permissions(const int32_t seqid);
  void remove(const std::string& path);
  int32_t send_remove(const std::string& path);
  void recv_remove(const int32_t seqid);
  void remove_all(const std::string& path);
  int32_t send_remove_all(const std::string& path);
  void recv_remove_all(const int32_t seqid);
  void sync(const std::string& path, const std::string& backing_path);
  int32_t send_sync(const std::string& path, const std::string& backing_path);
  void recv_sync(const int32_t seqid);
  void dump(const std::string& path, const std::string& backing_path);
  int32_t send_dump(const std::string& path, const std::string& backing_path);
  void recv_dump(const int32_t seqid);
  void load(const std::string& path, const std::string& backing_path);
  int32_t send_load(const std::string& path, const std::string& backing_path);
  void recv_load(const int32_t seqid);
  void rename(const std::string& old_path, const std::string& new_path);
  int32_t send_rename(const std::string& old_path, const std::string& new_path);
  void recv_rename(const int32_t seqid);
  void status(rpc_file_status& _return, const std::string& path);
  int32_t send_status(const std::string& path);
  void recv_status(rpc_file_status& _return, const int32_t seqid);
  void directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path);
  int32_t send_directory_entries(const std::string& path);
  void recv_directory_entries(std::vector<rpc_dir_entry> & _return, const int32_t seqid);
  void recursive_directory_entries(std::vector<rpc_dir_entry> & _return, const std::string& path);
  int32_t send_recursive_directory_entries(const std::string& path);
  void recv_recursive_directory_entries(std::vector<rpc_dir_entry> & _return, const int32_t seqid);
  void dstatus(rpc_data_status& _return, const std::string& path);
  int32_t send_dstatus(const std::string& path);
  void recv_dstatus(rpc_data_status& _return, const int32_t seqid);
  void add_tags(const std::string& path, const std::map<std::string, std::string> & tags);
  int32_t send_add_tags(const std::string& path, const std::map<std::string, std::string> & tags);
  void recv_add_tags(const int32_t seqid);
  bool is_regular_file(const std::string& path);
  int32_t send_is_regular_file(const std::string& path);
  bool recv_is_regular_file(const int32_t seqid);
  bool is_directory(const std::string& path);
  int32_t send_is_directory(const std::string& path);
  bool recv_is_directory(const int32_t seqid);
  void reslove_failures(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain);
  int32_t send_reslove_failures(const std::string& path, const rpc_replica_chain& chain);
  void recv_reslove_failures(rpc_replica_chain& _return, const int32_t seqid);
  void add_replica_to_chain(rpc_replica_chain& _return, const std::string& path, const rpc_replica_chain& chain);
  int32_t send_add_replica_to_chain(const std::string& path, const rpc_replica_chain& chain);
  void recv_add_replica_to_chain(rpc_replica_chain& _return, const int32_t seqid);
  void add_data_block(rpc_replica_chain& _return, const std::string& path, const std::string& partition_name, const std::string& partition_metadata);
  int32_t send_add_data_block(const std::string& path, const std::string& partition_name, const std::string& partition_metadata);
  void recv_add_data_block(rpc_replica_chain& _return, const int32_t seqid);
  void remove_data_block(const std::string& path, const std::string& partition_name);
  int32_t send_remove_data_block(const std::string& path, const std::string& partition_name);
  void recv_remove_data_block(const int32_t seqid);
  void request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata);
  int32_t send_request_partition_data_update(const std::string& path, const std::string& old_partition_name, const std::string& new_partition_name, const std::string& partition_metadata);
  void recv_request_partition_data_update(const int32_t seqid);
  int64_t get_storage_capacity(const std::string& path, const std::string& partition_name);
  int32_t send_get_storage_capacity(const std::string& path, const std::string& partition_name);
  int64_t recv_get_storage_capacity(const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< Protocol_> piprot_;
  apache::thrift::stdcxx::shared_ptr< Protocol_> poprot_;
  Protocol_* iprot_;
  Protocol_* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

typedef directory_serviceConcurrentClientT< ::apache::thrift::protocol::TProtocol> directory_serviceConcurrentClient;

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}} // namespace

#include "directory_service.tcc"
#include "directory_service_types.tcc"

#endif
