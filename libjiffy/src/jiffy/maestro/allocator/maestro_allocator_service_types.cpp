/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "maestro_allocator_service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jiffy { namespace maestro {


maestro_allocator_service_exception::~maestro_allocator_service_exception() noexcept {
}


void maestro_allocator_service_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const maestro_allocator_service_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(maestro_allocator_service_exception &a, maestro_allocator_service_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

maestro_allocator_service_exception::maestro_allocator_service_exception(const maestro_allocator_service_exception& other0) : TException() {
  msg = other0.msg;
  __isset = other0.__isset;
}
maestro_allocator_service_exception& maestro_allocator_service_exception::operator=(const maestro_allocator_service_exception& other1) {
  msg = other1.msg;
  __isset = other1.__isset;
  return *this;
}
void maestro_allocator_service_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "maestro_allocator_service_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* maestro_allocator_service_exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: maestro_allocator_service_exception";
  }
}


block::~block() noexcept {
}


void block::__set_block_id(const std::string& val) {
  this->block_id = val;
}

void block::__set_sequence_number(const int64_t val) {
  this->sequence_number = val;
}
std::ostream& operator<<(std::ostream& out, const block& obj)
{
  obj.printTo(out);
  return out;
}


void swap(block &a, block &b) {
  using ::std::swap;
  swap(a.block_id, b.block_id);
  swap(a.sequence_number, b.sequence_number);
}

block::block(const block& other2) {
  block_id = other2.block_id;
  sequence_number = other2.sequence_number;
}
block& block::operator=(const block& other3) {
  block_id = other3.block_id;
  sequence_number = other3.sequence_number;
  return *this;
}
void block::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "block(";
  out << "block_id=" << to_string(block_id);
  out << ", " << "sequence_number=" << to_string(sequence_number);
  out << ")";
}

}} // namespace
